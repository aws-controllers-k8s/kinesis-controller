// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License"). You may
// not use this file except in compliance with the License. A copy of the
// License is located at
//
//     http://aws.amazon.com/apache2.0/
//
// or in the "license" file accompanying this file. This file is distributed
// on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
// express or implied. See the License for the specific language governing
// permissions and limitations under the License.

// Code generated by ack-generate. DO NOT EDIT.

package v1alpha1

import (
	ackv1alpha1 "github.com/aws-controllers-k8s/runtime/apis/core/v1alpha1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// StreamSpec defines the desired state of Stream.
type StreamSpec struct {

	// A name to identify the stream. The stream name is scoped to the Amazon Web
	// Services account used by the application that creates the stream. It is also
	// scoped by Amazon Web Services Region. That is, two streams in two different
	// Amazon Web Services accounts can have the same name. Two streams in the same
	// Amazon Web Services account but in two different Regions can also have the
	// same name.
	// +kubebuilder:validation:Required
	Name *string `json:"name"`
	// The number of shards that the stream will use. The throughput of the stream
	// is a function of the number of shards; more shards are required for greater
	// provisioned throughput.
	ShardCount *int64 `json:"shardCount,omitempty"`
	// Indicates the capacity mode of the data stream. Currently, in Kinesis Data
	// Streams, you can choose between an on-demand capacity mode and a provisioned
	// capacity mode for your data streams.
	StreamModeDetails *StreamModeDetails `json:"streamModeDetails,omitempty"`
}

// StreamStatus defines the observed state of Stream
type StreamStatus struct {
	// All CRs managed by ACK have a common `Status.ACKResourceMetadata` member
	// that is used to contain resource sync state, account ownership,
	// constructed ARN for the resource
	// +kubebuilder:validation:Optional
	ACKResourceMetadata *ackv1alpha1.ResourceMetadata `json:"ackResourceMetadata"`
	// All CRs managed by ACK have a common `Status.Conditions` member that
	// contains a collection of `ackv1alpha1.Condition` objects that describe
	// the various terminal states of the CR and its backend AWS service API
	// resource
	// +kubebuilder:validation:Optional
	Conditions []*ackv1alpha1.Condition `json:"conditions"`
	// The number of enhanced fan-out consumers registered with the stream.
	// +kubebuilder:validation:Optional
	ConsumerCount *int64 `json:"consumerCount,omitempty"`
	// The encryption type used. This value is one of the following:
	//
	//    * KMS
	//
	//    * NONE
	// +kubebuilder:validation:Optional
	EncryptionType *string `json:"encryptionType,omitempty"`
	// Represents the current enhanced monitoring settings of the stream.
	// +kubebuilder:validation:Optional
	EnhancedMonitoring []*EnhancedMetrics `json:"enhancedMonitoring,omitempty"`
	// The GUID for the customer-managed Amazon Web Services KMS key to use for
	// encryption. This value can be a globally unique identifier, a fully specified
	// ARN to either an alias or a key, or an alias name prefixed by "alias/".You
	// can also use a master key owned by Kinesis Data Streams by specifying the
	// alias aws/kinesis.
	//
	//    * Key ARN example: arn:aws:kms:us-east-1:123456789012:key/12345678-1234-1234-1234-123456789012
	//
	//    * Alias ARN example: arn:aws:kms:us-east-1:123456789012:alias/MyAliasName
	//
	//    * Globally unique key ID example: 12345678-1234-1234-1234-123456789012
	//
	//    * Alias name example: alias/MyAliasName
	//
	//    * Master key owned by Kinesis Data Streams: alias/aws/kinesis
	// +kubebuilder:validation:Optional
	KeyID *string `json:"keyID,omitempty"`
	// The number of open shards in the stream.
	// +kubebuilder:validation:Optional
	OpenShardCount *int64 `json:"openShardCount,omitempty"`
	// The current retention period, in hours.
	// +kubebuilder:validation:Optional
	RetentionPeriodHours *int64 `json:"retentionPeriodHours,omitempty"`
	// The approximate time that the stream was created.
	// +kubebuilder:validation:Optional
	StreamCreationTimestamp *metav1.Time `json:"streamCreationTimestamp,omitempty"`
	// The current status of the stream being described. The stream status is one
	// of the following states:
	//
	//    * CREATING - The stream is being created. Kinesis Data Streams immediately
	//    returns and sets StreamStatus to CREATING.
	//
	//    * DELETING - The stream is being deleted. The specified stream is in the
	//    DELETING state until Kinesis Data Streams completes the deletion.
	//
	//    * ACTIVE - The stream exists and is ready for read and write operations
	//    or deletion. You should perform read and write operations only on an ACTIVE
	//    stream.
	//
	//    * UPDATING - Shards in the stream are being merged or split. Read and
	//    write operations continue to work while the stream is in the UPDATING
	//    state.
	// +kubebuilder:validation:Optional
	StreamStatus *string `json:"streamStatus,omitempty"`
}

// Stream is the Schema for the Streams API
// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
type Stream struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              StreamSpec   `json:"spec,omitempty"`
	Status            StreamStatus `json:"status,omitempty"`
}

// StreamList contains a list of Stream
// +kubebuilder:object:root=true
type StreamList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Stream `json:"items"`
}

func init() {
	SchemeBuilder.Register(&Stream{}, &StreamList{})
}
